% !TEX root = ../main.tex

\chapter{TokenHook: Secure ERC-20 Smart Contract}\label{ch:tokenhook}

\textit{This chapter is based on the paper "TokenHook: Secure ERC-20 Smart Contract"~\cite{token2021} supervised by Dr. \supv.}
	
\section{Introduction}
In this chapter, we present a summary of our research on ERC-20 vulnerabilities and a new proposal, TokenHook, as a secure ERC-20 token contract. Of the 2.5M smart contracts on the Ethereum network~\cite{Alethio}, 260K are tokens~\cite{TokenTracker} and 98\% of these tokens are ERC-20. Although various token standards (\eg ERC-721, ERC-777, ERC-1155) have been introduced by the Ethereum community, ERC-20 is widely used for industrial implementations. Therefore, our research focus is on ERC-20 tokens.

The authors of the ERC-20 standard reference two sample implementations: one that is actively maintained by OpenZeppelin~\cite{OpenZeppelin_Token} and one that has been deprecated by ConsenSys~\cite{ConsenSys_Token} (and now refers to the OpenZeppelin implementation). As expected, the OpenZeppelin template is very popular within the Ethereum developers \cite{OpenZeppelin1,OpenZeppelin2,OpenZeppelin3}. However, diversity in software is important for robustness and security~\cite{FSA97,FHS97}. For ERC-20, a variety of implementations will reduce the impact of a single bug in a single implementation. For example, between 17 March 2017 and 13 July 2017, OpenZeppelin's implementation used the wrong interface and affected 130 tokens~\cite{TokenBug}. This is also one the cases that motivated us for using our experience to provide a new secure implementation of the ERC-20 interface called TokenHook. It is freely available and can be used by developers as a reference implementation.

TokenHook is our compliant ERC-20 implementation written in Vyper (v. 0.2.8) and Solidity (v. 0.8.4).\anote{token} It can be customized by developers, who can refer to each mitigation technique separately and address specific attacks. Required comments have been also added to clarify the usage of each function. Standard functionalities of the token (\ie   \texttt{approve()}, \texttt{transfer()}, \texttt{transferFrom()}, \etc) have been unit tested. A demonstration of token interactions and event triggering can also be seen on Etherscan\anote{interactions}. 

Among the layers of the Ethereum blockchain, ERC-20 tokens fall under the \textit{Contract layer} in which dApps are executed. The presence of a security vulnerability in supplementary layers affect the entire Ethereum blockchain, not necessarily ERC-20 tokens. Therefore, vulnerabilities in other layers are assumed to be out of the scope TokenHook implementation. (\eg \textit{Indistinguishable chains} at the data layer, the \textit{51\% attack} at the consensus layer, \textit{Unlimited nodes creation} at network layer, and \textit{Web3.js Arbitrary File Write} at application layer). Moreover, we exclude vulnerabilities identified in now outdated compiler versions. Examples: \textit{Constructor name ambiguity} in versions before 0.4.22, \textit{Uninitialized storage pointer} in versions before 0.5.0, \textit{Function default visibility} in versions before 0.5.0, \textit{Typographical error} in versions before 0.5.8, \textit{Deprecated solidity functions} in versions before 0.4.25, \textit{Assert Violation} in versions before 0.4.10, \textit{Under-priced DoS attack} before EIP-150 \& EIP-1884).

\subsection{Security features}
In our research, we develop 82 security vulnerabilities and best practices for ERC-20 standard. We concentrate here on how TokenHook mitigates these attacks. While many of these attacks are no doubt very familiar to the reader, our emphasis is on their relevance to ERC-20 smart contract. We sample some high profile vulnerabilities, typically ones that have been exploited in real world ERC-20 tokens \cite{SolidtySecBlog,EthSecServ,SoliditySecCon,ConsensysSecCon,LandoKL}. For each, we (i) briefly explain technical details, (ii) the ability to affect ERC-20 tokens, and (iii) discuss mitigation techniques. Some of these vulnerabilities are:

\subsubsection{Multiple Withdrawal Attack} An attacker can use a front-running attack~\cite{OrderingAttack,eskandari2019sok} to transfer more tokens than what is intended (approved) by the token holder. We secure the \texttt{transferFrom()} function by tracking transferred tokens to mitigate the \mwa~\cite{MultipleWithdrawal}. Securing the \texttt{transferFrom()} function is fully compliant with the ERC-20 standard without the need of introducing new functions such as \texttt{decreaseApproval()} and \texttt{increaseApproval()}. 

\subsubsection{Arithmetic Over/Under Flows} In Solidity implementation, we use the \texttt{SafeMath} library in all arithmetic operations to catch over/under flows. Using it in Vyper is not required due to built-in checks.

\subsubsection{Re-entrancy} At first glance, re-entrancy might seem inapplicable to ERC-20. However any function that changes internal state, such as balances, need to be checked. We use Checks-Effects-Interactions pattern (CEI)~\cite{CEI} in both Vyper and Solidity implementations to mitigate \textit{same-function re-entrancy} attack. Mutual exclusion (Mutex)~\cite{WiKiMutex} is also used to address \textit{cross-function re-entrancy} attack. Vyper supports Mutex decorator on a function and we use \texttt{noReentrancy} modifier in Solidity to apply Mutex. Therefore, both re-entrancy variants are addressed in TokenHook. 

\subsubsection{Unchecked return values} Unlike built-in support in Vyper, we must check the return value of \texttt{call.value()} in Solidity to revert failed fund transfers. It mitigates the \textit{unchecked return values} attack while making the token contract compatible with EIP-1884~\cite{EIP1884}. 

\subsubsection{Frozen Ether} We mitigate this issue by defining a \texttt{withdraw()} function that allows the owner to transfer all Ether out of the token contract. Otherwise, unexpected Ether forced onto the token contract (\eg from another contract running \texttt{selfdestruct}) will be stuck forever. 

\subsubsection{Unprotected Ether Withdrawal} We enforce authentication before transferring any funds out of the contract to mitigate \textit{unprotected Ether withdrawal}. Explicit check is added to the Vyper code and \texttt{onlyOwner} modifier is used in Solidity implementation. It allows only owner to call \texttt{withdraw()} function and protects unauthorized Ether withdrawals. 

\subsubsection{State variable manipulation} In the Solidity implementation, we use embedded \texttt{Library} code (for \texttt{SafeMath}) to avoid external calls and mitigate the \textit{state variable manipulation} attack. It also reduces gas costs since calling functions in embedded libraries requires less gas than external calls.

\subsubsection{Function visibility} We carefully define the visibility of each function. Most of the functions are declared as \texttt{External} (\eg \texttt{Approve()}, \texttt{Transfer()}, \etc) per specifications of ERC-20 standard.

\subsection{Best practices and enhancements}
We also highlight a few best practices that have been accepted by the Ethereum community to proactively prevent known vulnerabilities~\cite{TokenBP}. Some best practices are specific to ERC-20, while others are generic for all dApps --- in which case, we discuss their relevance to ERC-20 standard. Some of these best practices are:

\subsubsection{Compliance with ERC-20} We implement all ERC-20 functions to make it fully compatible with the standard. Compliance is important for ensuring that other DApps and web apps (\ie crypto-wallets, crypto-exchanges and web services) compose with TokenHook as expected. 

\subsubsection{External visibility} To improve performance, we apply an \texttt{external} visibility (instead of \texttt{public} visibility in the standard) for interactive functions (\eg \texttt{approve()} and \texttt{transfer()}, \etc).  External functions can read arguments directly from non-persistent \texttt{calldata} instead of allocating persistent memory by the EVM. 

\subsubsection{Fail-Safe Mode} We implement a `cease trade' operation that will freeze the token in the case of new security threats or new legal requirements (\eg Liberty Reserve ~\cite{LibertyReserve} or TON cryptocurrency~\cite{TON}). To freeze all functionality of TokenHook, the owner (or multiple parties) can call the function \texttt{pause()} which sets a lock variable. All critical methods are either marked with a \texttt{notPaused} modifier (in Solidity) or explicit check (in Vyper), that will throw exceptions until functionality is restored using \texttt{unpause()}. 

\subsubsection{Firing events} We define nine extra events: \texttt{Buy}, \texttt{Sell}, \texttt{Received}, \texttt{Withdrawal}, \texttt{Pause}, \texttt{Change}, \texttt{ChangeOwner}, \texttt{Mint} and \texttt{Burn}. The name of each event indicates its function except \texttt{Change} event which logs any state variable updates. It can be used to watch for token inconsistent behavior (\eg via TokenScope~\cite{TokenScope}) and react accordingly. 

\subsubsection{Global or Miner controlled variables}
Since malicious miners are able to manipulate global Solidity variables (\eg \texttt{block.timestamp}, \texttt{block.number}, \texttt{block.difficulty}, \etc), it is recommended to avoid these variables in ERC-20 tokens.

\subsubsection{DoS with block gas limit}
The use of loops in contracts is not efficient and may lead to DoS attack. If execution of a function exceeds the block gas limit, all transactions in that block will fail. Hence, it is recommended to not use loops and rely on \texttt{mappings} variables which store data in collection of key value pairs and are more efficient for tracking owned tokens by each holder.

\subsubsection{Proxy contracts} We choose to make TokenHook non-upgradable so it can be audited, and upgrades will not introduce new vulnerabilities that did not exist at the initial audit. 

\subsubsection{Other enhancements} We also follow other best practices such as not using batch processing in \texttt{sell()} function to avoid \textit{DoS with unexpected revert} issue, not using miner controlled variable in conditional statements, and not using \texttt{SELFDESTRUCT}.



\subsection{Need for another reference implementation}
OpenZeppelin's implementation is actually part of a small portfolio of implementations (ERC-20, ERC-721, ERC-777, and ERC-1155). Code reuse across the four implementations adds complexity for a developer that only wants ERC-20. This might be the reason for not supporting Vyper in OpenZeppelin's implementation. No inheritance in Vyper requires different implementation than the current object-oriented OpenZeppelin contracts. Further, most audit tools are not able to import libraries/interfaces from external files (\eg SafeMath.sol, IERC20.sol). By contrast, TokenHook uses a flat layout in a single file that is specific to ERC-20. It does not use inheritance in Solidity which allows similar implementation in Vyper.

\ExecuteMetaData[sections/tables]{tab-impl}

Although Vyper offers less features than Solidity (\eg no class inheritance, modifiers, inline assembly, function/operator overloading, \etc~\cite{SolidityDoc}), the Vyper compiler includes built-in security checks. Table~\ref{tab:compare} provides a comparison between the two from the perspective of TokenHook (see~\cite{Vyper1} for a broader comparison on vulnerabilities). Security and performance are advantages of Vyper. However, Vyper may not be a preferred option for production (``Vyper is beta software, use with care''~\cite{VyperReadme}), most of the auditing tools only support Solidity,\footnote{Vyper support is recently added to some tools (\eg Crytic-compile, Manticore and Echidna). Slither integration is still in progress~\cite{Crytic}} and Solidity currently enjoys widespread implementation, developer tools, and developer experience.

\subsection{Audit results}
To determine the extent to which TokenHook addresses the outlined issues, We conducted an experiment on code auditing tools using the Solidity implementation of TokenHook to understand the current state of automated vulnerability testing. Each tool uses different techniques (\eg Symbolic execution, Fuzzing, Static analysis, \etc) and reveal potential vulnerabilities. Our results illuminate the (in)completeness and error-rate of such tools on one specific use-case (related work studies, in greater width and less depth, a variety of use-cases~\cite{AuditTools}). We did not adapt older tools that support significantly lower versions of the Solidity compiler (\eg Oyente). We concentrated on Solidity as Vyper analysis is currently a paid services or penciled in for future support (\eg Slither). The provided version number is based on the GitHub repository and tools without a version are web-based:
\begin{enumerate}
	\item EY Smart Contract \& Token Review by Ernst \& Young Global Limited~\cite{EYTool}.
	\item SmartCheck by SmartDec~\cite{SMARTCHECK}.
	\item Securify v2.0 by ChainSecurity~\cite{SECURIFYGIT,SECURIFY}.
	\item ContractGuard by GuardStrike~\cite{ContractGuard}.
	\item MythX by ConsenSys~\cite{MythX}.
	\item Slither Analyzer v0.6.12 by Crytic~\cite{SlitherDoc}.
	\item Odin by Sooho~\cite{Odin}.
\end{enumerate}
Tables \ref{tab:result1}, \ref{tab:result2} and \ref{tab:result3} summarize audit results by including best practices and security vulnerabilities. To compile the list of 82, we referenced the knowledge-base of each tool~\cite{SECURIFYGIT,SMARTCHECK,MythX,ContractGuard,SlitherDoc}, understood each threat, manually mapped the audit to the corresponding SWC registry~\cite{SWC}, and manually determined when different tools were testing for the same vulnerability or best practice (which was not always clear from the tools' own descriptions). Since each tool employs different methodology to analyze codes (\eg comparing with violation patterns, applying a set of rules, using static analysis, \etc), there are false positives to manually check. Many false positives are not simply due to old/unmaintained rules but actually require tool improvement.

\ExecuteMetaData[sections/tables]{tab-result1}
\ExecuteMetaData[sections/tables]{tab-result2}
\ExecuteMetaData[sections/tables]{tab-result3}

After manually overriding the false positives, the average percentage of passed checks for TokenHook reaches to 99.5\%. To pass the one missing check and reach a 100\% success rate across all tools, we prepared the same code in Solidity version 0.8.4, however it cannot be audited anymore with most of the tools. We repeated the same auditing process on the top ten tokens based on their market cap~\cite{TokenTracker}. The result of all these evaluation have been summarized in Table \ref{tab:summary} by considering false positives as failed audits. This provides the same evaluation conditions across all tokens. Since each tool uses different analysis methods, number of occurrences are considered for comparisons. For instance, MythX detects two \textit{re-entrancy} in TokenHook; therefore, two occurrences are counted instead of one. As it can be seen in Table \ref{tab:summary}, TokenHook has the least number of security flaws (occurrences) compared to other tokens.

We stress that detected security issues for TokenHook are all false positives. We are also up-front that this metric is not a perfect indication of security. The other tokens may also have many/all false positives, and not all true positives can be exploited~\cite{VulExp}. Mainly, we want to show this measurement as being consistent with our claims around the security of TokenHook. If TokenHook, for example, had the highest number of occurrences, it would be a major red flag.

\ExecuteMetaData[sections/tables]{tab-summary}

\section{Contributions}
We provide a detailed study of ERC-20 token security, collecting and deduplicating applicable vulnerabilities and best practices, examining the ability of seven audit tools. Most importantly, we provide a concrete implementation of ERC-20 called TokenHook.\anote{versions} It is designed to be secure against known vulnerabilities, and can serve as a second reference implementation to provide software diversity. We test it at Solidity version 0.5.11 (due to the limitation of the audit tools) and also provide it at version 0.8.4. Vyper implementation is also provided at version 0.2.8 to make ERC-20 smart contracts more secure and easier to audit.

TokenHook can be used as template to deploy new ERC-20 tokens, migrate current vulnerable deployments, and to benchmark the precision of Ethereum audit tools. This chapter has focused more on the technical aspects of smart contracts and securing ERC-20 tokens. The most important contribution can be summarized as follows:
\begin{enumerate}
	\item Identify security vulnerabilities specific to ERC-20 tokens.
	
	\item Create the first online knowledge-base for ERC-20 tokens that can be referenced by developers and auditors.
	
	\item Propose a secure ERC-20 implementation, TokenHook, that can be used as a template for real-world scenarios (\ie ICOs, dApps, \etc).
	
	\item Consider best practices\footnote{Best practices are techniques or rules that are accepted to develop the most effective smart contract.} in addition to the known vulnerabilities to improve performance of the token contract while prevent attacks.
	
	\item Use audit tools to evaluate security of the proposed code.
\end{enumerate}

\section{Discussion}
The main challenge in securing smart contracts is their immutable property. After deploying a buggy smart contract on the blockchain, it would not be possible to patch it as in classical applications. It becomes immutable and irreversible. Therefore, the focus of developers should be on avoiding known security flaws and considering required security measures before deploying smart contracts (and tokens as a subset of them). This motivates us to (i) comprehensively study all known vulnerabilities in smart contracts and particularly in ERC-20 tokens, (ii) systematize them into a set of 82 distinct vulnerabilities and best practices that can be referenced by developers and auditors, (iii) use our experience to provide a new secure implementation of the ERC-20, TokenHook, that is freely available, and (iv) confirm the security of TokenHook by using seven different audit tools and comparing the results with the top 10 ERC-20 tokens. 

In short, TokenHook enhances security of ERC-20 tokens and ensures stronger compliance with best practices compared to the sole surviving reference implementation (from OpenZeppelin). All these contributions are aimed at strengthening user protection by improving the security of the deployed contracts.